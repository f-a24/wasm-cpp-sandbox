/** *** */ (function (modules) {
  // webpackBootstrap
  /** *** */ // The module cache
  /** *** */ const installedModules = {}; // The require function
  /** *** */
  /** *** */ /** *** */ function __webpack_require__(moduleId) {
    /** *** */
    /** *** */ // Check if module is in cache
    /** *** */ if (installedModules[moduleId]) {
      /** *** */ return installedModules[moduleId].exports;
      /** *** */
    } // Create a new module (and put it into the cache)
    /** *** */ /** *** */ const module = (installedModules[moduleId] = {
      /** *** */ i: moduleId,
      /** *** */ l: false,
      /** *** */ exports: {}
      /** *** */
    }); // Execute the module function
    /** *** */
    /** *** */ /** *** */ modules[moduleId].call(
      module.exports,
      module,
      module.exports,
      __webpack_require__
    ); // Flag the module as loaded
    /** *** */
    /** *** */ /** *** */ module.l = true; // Return the exports of the module
    /** *** */
    /** *** */ /** *** */ return module.exports;
    /** *** */
  } // expose the modules object (__webpack_modules__)
  /** *** */
  /** *** */
  /** *** */ /** *** */ __webpack_require__.m = modules; // expose the module cache
  /** *** */
  /** *** */ /** *** */ __webpack_require__.c = installedModules; // define getter function for harmony exports
  /** *** */
  /** *** */ /** *** */ __webpack_require__.d = function (exports, name, getter) {
    /** *** */ if (!__webpack_require__.o(exports, name)) {
      /** *** */ Object.defineProperty(exports, name, { enumerable: true, get: getter });
      /** *** */
    }
    /** *** */
  }; // define __esModule on exports
  /** *** */
  /** *** */ /** *** */ __webpack_require__.r = function (exports) {
    /** *** */ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /** *** */ Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      /** *** */
    }
    /** *** */ Object.defineProperty(exports, '__esModule', { value: true });
    /** *** */
  }; // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
  /** *** */
  /** *** */ /** *** */ /** *** */ /** *** */ /** *** */ /** *** */ __webpack_require__.t = function (
    value,
    mode
  ) {
    /** *** */ if (mode & 1) value = __webpack_require__(value);
    /** *** */ if (mode & 8) return value;
    /** *** */ if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
    /** *** */ const ns = Object.create(null);
    /** *** */ __webpack_require__.r(ns);
    /** *** */ Object.defineProperty(ns, 'default', { enumerable: true, value });
    /** *** */ if (mode & 2 && typeof value !== 'string') {
      for (const key in value) {
        __webpack_require__.d(
          ns,
          key,
          ((key) => value[key]).bind(null, key)
        );
      }
    }
    /** *** */ return ns;
    /** *** */
  }; // getDefaultExport function for compatibility with non-harmony modules
  /** *** */
  /** *** */ /** *** */ __webpack_require__.n = function (module) {
    /** *** */ const getter = module && module.__esModule
      ? /** *** */ function getDefault() {
        return module.default;
      }
      : /** *** */ function getModuleExports() {
        return module;
      };
    /** *** */ __webpack_require__.d(getter, 'a', getter);
    /** *** */ return getter;
    /** *** */
  }; // Object.prototype.hasOwnProperty.call
  /** *** */
  /** *** */ /** *** */ __webpack_require__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }; // __webpack_public_path__
  /** *** */
  /** *** */ /** *** */ __webpack_require__.p = ''; // Load entry module and return exports
  /** *** */
  /** *** */
  /** *** */ /** *** */ return __webpack_require__((__webpack_require__.s = './src/js/index.js'));
  /** *** */
}(
  /** ********************************************************************* */
  /** *** */ {
    /** */ './node_modules/path-browserify/index.js':
    /*! ***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \********************************************** */
    /*! no static exports found */
    /** */ function (module, exports, __webpack_require__) {
      eval(
        "/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/path-browserify/index.js?"
      );

      /** */
    },

    /** */ './node_modules/process/browser.js':
    /*! *****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \**************************************** */
    /*! no static exports found */
    /** */ function (module, exports) {
      eval(
        "// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?"
      );

      /** */
    },

    /** */ './node_modules/webpack/buildin/amd-options.js':
    /*! ****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \*************************************** */
    /*! no static exports found */
    /** */ function (module, exports) {
      eval(
        '/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-options.js?'
      );

      /** */
    },

    /** */ './node_modules/webpack/buildin/harmony-module.js':
    /*! *******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \****************************************** */
    /*! no static exports found */
    /** */ function (module, exports) {
      eval(
        'module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, "loaded", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, "id", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, "exports", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/harmony-module.js?'
      );

      /** */
    },

    /** */ './src/js/App.js':
    /*! ***********************!*\
  !*** ./src/js/App.js ***!
  \********************** */
    /*! exports provided: default */
    /** */ function (module, __webpack_exports__, __webpack_require__) {
      eval(
        '__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = (function (wasmFn) {\n  return "<h1>Result ".concat(wasmFn(2, 3), "!!</h1>");\n});\n\n//# sourceURL=webpack:///./src/js/App.js?'
      );

      /** */
    },

    /** */ './src/js/index.js':
    /*! *************************!*\
  !*** ./src/js/index.js ***!
  \************************ */
    /*! no exports provided */
    /** */ function (module, __webpack_exports__, __webpack_require__) {
      eval(
        "__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App */ \"./src/js/App.js\");\n/* harmony import */ var _sass_style_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../sass/style.scss */ \"./src/sass/style.scss\");\n/* harmony import */ var _sass_style_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_sass_style_scss__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _wasm_add__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../wasm/add */ \"./wasm/add.js\");\n\n\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  fetch('./add.wasm').then(function (response) {\n    return response.arrayBuffer();\n  }).then(function (buffer) {\n    return new Uint8Array(buffer);\n  }).then(function (binary) {\n    var module;\n    var moduleArgs = {\n      wasmBinary: binary,\n      onRuntimeInitialized: function onRuntimeInitialized() {\n        document.getElementsByTagName('body')[0].innerHTML = Object(_App__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(module.cwrap('add', 'number', ['number', 'number']));\n      }\n    };\n    module = Object(_wasm_add__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(moduleArgs);\n  });\n});\n\n//# sourceURL=webpack:///./src/js/index.js?"
      );

      /** */
    },

    /** */ './src/sass/style.scss':
    /*! *****************************!*\
  !*** ./src/sass/style.scss ***!
  \**************************** */
    /*! no static exports found */
    /** */ function (module, exports) {
      eval(
        '// removed by extract-text-webpack-plugin\n\n//# sourceURL=webpack:///./src/sass/style.scss?'
      );

      /** */
    },

    /** */ './wasm/add.js':
    /*! *********************!*\
  !*** ./wasm/add.js ***!
  \******************** */
    /*! exports provided: default */
    /** */ function (module, __webpack_exports__, __webpack_require__) {
      eval(
        "__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(process, __dirname, module) {function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar Module = function () {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n\n  return function (Module) {\n    Module = Module || {}; // The Module object: Our interface to the outside world. We import\n    // and export values on it. There are various ways Module can be used:\n    // 1. Not defined. We create it here\n    // 2. A function parameter, function(Module) { ..generated code.. }\n    // 3. pre-run appended it, var Module = {}; ..generated code..\n    // 4. External script tag defines var Module.\n    // We need to check if Module already exists (e.g. case 3 above).\n    // Substitution will be replaced with actual code on later stage of the build,\n    // this way Closure Compiler will not mangle it (e.g. case 4. above).\n    // Note that if you want to run closure, and also to use Module\n    // after the generated code, you will need to define   var Module = {};\n    // before the code. Then that object will be used in the code, and you\n    // can continue to use Module afterwards as well.\n\n    var Module = typeof Module !== 'undefined' ? Module : {}; // --pre-jses are emitted after the Module integration code, so that they can\n    // refer to Module (if they choose; they can also define Module)\n    // {{PRE_JSES}}\n    // Sometimes an existing Module object exists with properties\n    // meant to overwrite the default module functionality. Here\n    // we collect those properties and reapply _after_ we configure\n    // the current environment's defaults to avoid having to be so\n    // defensive during initialization.\n\n    var moduleOverrides = {};\n    var key;\n\n    for (key in Module) {\n      if (Module.hasOwnProperty(key)) {\n        moduleOverrides[key] = Module[key];\n      }\n    }\n\n    Module['arguments'] = [];\n    Module['thisProgram'] = './this.program';\n\n    Module['quit'] = function (status, toThrow) {\n      throw toThrow;\n    };\n\n    Module['preRun'] = [];\n    Module['postRun'] = []; // Determine the runtime environment we are in. You can customize this by\n    // setting the ENVIRONMENT setting at compile time (see settings.js).\n\n    var ENVIRONMENT_IS_WEB = false;\n    var ENVIRONMENT_IS_WORKER = false;\n    var ENVIRONMENT_IS_NODE = false;\n    var ENVIRONMENT_IS_SHELL = false;\n    ENVIRONMENT_IS_WEB = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object';\n    ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';\n    ENVIRONMENT_IS_NODE = (typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === 'object' && \"function\" === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\n    ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\n    if (Module['ENVIRONMENT']) {\n      throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');\n    } // Three configurations we can be running in:\n    // 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)\n    // 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)\n    // 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)\n\n\n    assert(typeof Module['memoryInitializerPrefixURL'] === 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\n    assert(typeof Module['pthreadMainPrefixURL'] === 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\n    assert(typeof Module['cdInitializerPrefixURL'] === 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\n    assert(typeof Module['filePackagePrefixURL'] === 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead'); // `/` should be present at the end if `scriptDirectory` is not empty\n\n    var scriptDirectory = '';\n\n    function locateFile(path) {\n      if (Module['locateFile']) {\n        return Module['locateFile'](path, scriptDirectory);\n      } else {\n        return scriptDirectory + path;\n      }\n    }\n\n    if (ENVIRONMENT_IS_NODE) {\n      scriptDirectory = __dirname + '/'; // Expose functionality in the same simple way that the shells work\n      // Note that we pollute the global namespace here, otherwise we break in node\n\n      var nodeFS;\n      var nodePath;\n\n      Module['read'] = function shell_read(filename, binary) {\n        var ret;\n        if (!nodeFS) nodeFS = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n        if (!nodePath) nodePath = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n        filename = nodePath['normalize'](filename);\n        ret = nodeFS['readFileSync'](filename);\n        return binary ? ret : ret.toString();\n      };\n\n      Module['readBinary'] = function readBinary(filename) {\n        var ret = Module['read'](filename, true);\n\n        if (!ret.buffer) {\n          ret = new Uint8Array(ret);\n        }\n\n        assert(ret.buffer);\n        return ret;\n      };\n\n      if (process['argv'].length > 1) {\n        Module['thisProgram'] = process['argv'][1].replace(/\\\\/g, '/');\n      }\n\n      Module['arguments'] = process['argv'].slice(2); // MODULARIZE will export the module in the proper place outside, we don't need to export here\n\n      process['on']('uncaughtException', function (ex) {\n        // suppress ExitStatus exceptions from showing an error\n        if (!(ex instanceof ExitStatus)) {\n          throw ex;\n        }\n      }); // Currently node will swallow unhandled rejections, but this behavior is\n      // deprecated, and in the future it will exit with error status.\n\n      process['on']('unhandledRejection', function (reason, p) {\n        err('node.js exiting due to unhandled promise rejection');\n        process['exit'](1);\n      });\n\n      Module['quit'] = function (status) {\n        process['exit'](status);\n      };\n\n      Module['inspect'] = function () {\n        return '[Emscripten Module object]';\n      };\n    } else if (ENVIRONMENT_IS_SHELL) {\n      if (typeof read != 'undefined') {\n        Module['read'] = function shell_read(f) {\n          return read(f);\n        };\n      }\n\n      Module['readBinary'] = function readBinary(f) {\n        var data;\n\n        if (typeof readbuffer === 'function') {\n          return new Uint8Array(readbuffer(f));\n        }\n\n        data = read(f, 'binary');\n        assert(_typeof(data) === 'object');\n        return data;\n      };\n\n      if (typeof scriptArgs != 'undefined') {\n        Module['arguments'] = scriptArgs;\n      } else if (typeof arguments != 'undefined') {\n        Module['arguments'] = arguments;\n      }\n\n      if (typeof quit === 'function') {\n        Module['quit'] = function (status) {\n          quit(status);\n        };\n      }\n    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WEB) {\n        if (document.currentScript) {\n          scriptDirectory = document.currentScript.src;\n        }\n      } else {\n        // worker\n        scriptDirectory = self.location.href;\n      } // When MODULARIZE (and not _INSTANCE), this JS may be executed later, after document.currentScript\n      // is gone, so we saved it, and we use it here instead of any other info.\n\n\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      } // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n      // otherwise, slice off the final part of the url to find the script directory.\n\n\n      if (scriptDirectory.indexOf('blob:') !== 0) {\n        scriptDirectory = scriptDirectory.split('/').slice(0, -1).join('/') + '/';\n      } else {\n        scriptDirectory = '';\n      }\n\n      Module['read'] = function shell_read(url) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.send(null);\n        return xhr.responseText;\n      };\n\n      if (ENVIRONMENT_IS_WORKER) {\n        Module['readBinary'] = function readBinary(url) {\n          var xhr = new XMLHttpRequest();\n          xhr.open('GET', url, false);\n          xhr.responseType = 'arraybuffer';\n          xhr.send(null);\n          return new Uint8Array(xhr.response);\n        };\n      }\n\n      Module['readAsync'] = function readAsync(url, onload, onerror) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.responseType = 'arraybuffer';\n\n        xhr.onload = function xhr_onload() {\n          if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n            // file URLs can return 0\n            onload(xhr.response);\n            return;\n          }\n\n          onerror();\n        };\n\n        xhr.onerror = onerror;\n        xhr.send(null);\n      };\n\n      Module['setWindowTitle'] = function (title) {\n        document.title = title;\n      };\n    } else {\n      throw new Error('environment detection error');\n    } // Set up the out() and err() hooks, which are how we can print to stdout or\n    // stderr, respectively.\n    // If the user provided Module.print or printErr, use that. Otherwise,\n    // console.log is checked first, as 'print' on the web will open a print dialogue\n    // printErr is preferable to console.warn (works better in shells)\n    // bind(console) is necessary to fix IE/Edge closed dev tools panel behavior.\n\n\n    var out = Module['print'] || (typeof console !== 'undefined' ? console.log.bind(console) : typeof print !== 'undefined' ? print : null);\n    var err = Module['printErr'] || (typeof printErr !== 'undefined' ? printErr : typeof console !== 'undefined' && console.warn.bind(console) || out); // Merge back in the overrides\n\n    for (key in moduleOverrides) {\n      if (moduleOverrides.hasOwnProperty(key)) {\n        Module[key] = moduleOverrides[key];\n      }\n    } // Free the object hierarchy contained in the overrides, this lets the GC\n    // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\n\n\n    moduleOverrides = undefined; // {{PREAMBLE_ADDITIONS}}\n\n    var STACK_ALIGN = 16; // stack management, and other functionality that is provided by the compiled code,\n    // should not be used before it is ready\n\n    _stackSave = _stackRestore = stackAlloc = setTempRet0 = getTempRet0 = function getTempRet0() {\n      abort('cannot use the stack before compiled code is ready to run, and has provided stack access');\n    };\n\n    function staticAlloc(size) {\n      assert(!staticSealed);\n      var ret = STATICTOP;\n      STATICTOP = STATICTOP + size + 15 & -16;\n      assert(STATICTOP < TOTAL_MEMORY, 'not enough memory for static allocation - increase TOTAL_MEMORY');\n      return ret;\n    }\n\n    function dynamicAlloc(size) {\n      assert(DYNAMICTOP_PTR);\n      var ret = HEAP32[DYNAMICTOP_PTR >> 2];\n      var end = ret + size + 15 & -16;\n      HEAP32[DYNAMICTOP_PTR >> 2] = end;\n\n      if (end >= TOTAL_MEMORY) {\n        var success = enlargeMemory();\n\n        if (!success) {\n          HEAP32[DYNAMICTOP_PTR >> 2] = ret;\n          return 0;\n        }\n      }\n\n      return ret;\n    }\n\n    function alignMemory(size, factor) {\n      if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n\n      var ret = size = Math.ceil(size / factor) * factor;\n      return ret;\n    }\n\n    function getNativeTypeSize(type) {\n      switch (type) {\n        case 'i1':\n        case 'i8':\n          return 1;\n\n        case 'i16':\n          return 2;\n\n        case 'i32':\n          return 4;\n\n        case 'i64':\n          return 8;\n\n        case 'float':\n          return 4;\n\n        case 'double':\n          return 8;\n\n        default:\n          {\n            if (type[type.length - 1] === '*') {\n              return 4; // A pointer\n            } else if (type[0] === 'i') {\n              var bits = parseInt(type.substr(1));\n              assert(bits % 8 === 0);\n              return bits / 8;\n            } else {\n              return 0;\n            }\n          }\n      }\n    }\n\n    function warnOnce(text) {\n      if (!warnOnce.shown) warnOnce.shown = {};\n\n      if (!warnOnce.shown[text]) {\n        warnOnce.shown[text] = 1;\n        err(text);\n      }\n    }\n\n    var asm2wasmImports = {\n      // special asm2wasm imports\n      \"f64-rem\": function f64Rem(x, y) {\n        return x % y;\n      },\n      \"debugger\": function _debugger() {\n        debugger;\n      }\n    };\n    var jsCallStartIndex = 1;\n    var functionPointers = new Array(0); // 'sig' parameter is only used on LLVM wasm backend\n\n    function addFunction(func, sig) {\n      if (typeof sig === 'undefined') {\n        err('warning: addFunction(): You should provide a wasm function signature string as a second argument. This is not necessary for asm.js and asm2wasm, but is required for the LLVM wasm backend, so it is recommended for full portability.');\n      }\n\n      var base = 0;\n\n      for (var i = base; i < base + 0; i++) {\n        if (!functionPointers[i]) {\n          functionPointers[i] = func;\n          return jsCallStartIndex + i;\n        }\n      }\n\n      throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';\n    }\n\n    function removeFunction(index) {\n      functionPointers[index - jsCallStartIndex] = null;\n    }\n\n    var funcWrappers = {};\n\n    function getFuncWrapper(func, sig) {\n      if (!func) return; // on null pointer, return undefined\n\n      assert(sig);\n\n      if (!funcWrappers[sig]) {\n        funcWrappers[sig] = {};\n      }\n\n      var sigCache = funcWrappers[sig];\n\n      if (!sigCache[func]) {\n        // optimize away arguments usage in common cases\n        if (sig.length === 1) {\n          sigCache[func] = function dynCall_wrapper() {\n            return dynCall(sig, func);\n          };\n        } else if (sig.length === 2) {\n          sigCache[func] = function dynCall_wrapper(arg) {\n            return dynCall(sig, func, [arg]);\n          };\n        } else {\n          // general case\n          sigCache[func] = function dynCall_wrapper() {\n            return dynCall(sig, func, Array.prototype.slice.call(arguments));\n          };\n        }\n      }\n\n      return sigCache[func];\n    }\n\n    function makeBigInt(low, high, unsigned) {\n      return unsigned ? +(low >>> 0) + +(high >>> 0) * 4294967296.0 : +(low >>> 0) + +(high | 0) * 4294967296.0;\n    }\n\n    function dynCall(sig, ptr, args) {\n      if (args && args.length) {\n        assert(args.length == sig.length - 1);\n        assert('dynCall_' + sig in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n        return Module['dynCall_' + sig].apply(null, [ptr].concat(args));\n      } else {\n        assert(sig.length == 1);\n        assert('dynCall_' + sig in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n        return Module['dynCall_' + sig].call(null, ptr);\n      }\n    }\n\n    function getCompilerSetting(name) {\n      throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';\n    }\n\n    var Runtime = {\n      // FIXME backwards compatibility layer for ports. Support some Runtime.*\n      //       for now, fix it there, then remove it from here. That way we\n      //       can minimize any period of breakage.\n      dynCall: dynCall,\n      // for SDL2 port\n      // helpful errors\n      getTempRet0: function getTempRet0() {\n        abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n      },\n      staticAlloc: function staticAlloc() {\n        abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n      },\n      stackAlloc: function stackAlloc() {\n        abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n      }\n    }; // The address globals begin at. Very low in memory, for code size and optimization opportunities.\n    // Above 0 is static memory, starting with globals.\n    // Then the stack.\n    // Then 'dynamic' memory for sbrk.\n\n    var GLOBAL_BASE = 1024; // === Preamble library stuff ===\n    // Documentation for the public APIs defined in this file must be updated in:\n    //    site/source/docs/api_reference/preamble.js.rst\n    // A prebuilt local version of the documentation is available at:\n    //    site/build/text/docs/api_reference/preamble.js.txt\n    // You can also build docs locally as HTML or other formats in site/\n    // An online HTML version (which may be of a different version of Emscripten)\n    //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n    //========================================\n    // Runtime essentials\n    //========================================\n\n    var ABORT = 0; // whether we are quitting the application. no code should run after this. set in exit() and abort()\n\n    var EXITSTATUS = 0;\n    /** @type {function(*, string=)} */\n\n    function assert(condition, text) {\n      if (!condition) {\n        abort('Assertion failed: ' + text);\n      }\n    }\n\n    var globalScope = this; // Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\n\n    function getCFunc(ident) {\n      var func = Module['_' + ident]; // closure exported function\n\n      assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n      return func;\n    }\n\n    var JSfuncs = {\n      // Helpers for cwrap -- it can't refer to Runtime directly because it might\n      // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find\n      // out what the minified function name is.\n      'stackSave': function stackSave() {\n        _stackSave();\n      },\n      'stackRestore': function stackRestore() {\n        _stackRestore();\n      },\n      // type conversion from js to c\n      'arrayToC': function arrayToC(arr) {\n        var ret = stackAlloc(arr.length);\n        writeArrayToMemory(arr, ret);\n        return ret;\n      },\n      'stringToC': function stringToC(str) {\n        var ret = 0;\n\n        if (str !== null && str !== undefined && str !== 0) {\n          // null string\n          // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n          var len = (str.length << 2) + 1;\n          ret = stackAlloc(len);\n          stringToUTF8(str, ret, len);\n        }\n\n        return ret;\n      }\n    }; // For fast lookup of conversion functions\n\n    var toC = {\n      'string': JSfuncs['stringToC'],\n      'array': JSfuncs['arrayToC']\n    }; // C calling interface.\n\n    function ccall(ident, returnType, argTypes, args, opts) {\n      function convertReturnValue(ret) {\n        if (returnType === 'string') return Pointer_stringify(ret);\n        if (returnType === 'boolean') return Boolean(ret);\n        return ret;\n      }\n\n      var func = getCFunc(ident);\n      var cArgs = [];\n      var stack = 0;\n      assert(returnType !== 'array', 'Return type should not be \"array\".');\n\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          var converter = toC[argTypes[i]];\n\n          if (converter) {\n            if (stack === 0) stack = _stackSave();\n            cArgs[i] = converter(args[i]);\n          } else {\n            cArgs[i] = args[i];\n          }\n        }\n      }\n\n      var ret = func.apply(null, cArgs);\n      ret = convertReturnValue(ret);\n      if (stack !== 0) _stackRestore(stack);\n      return ret;\n    }\n\n    function cwrap(ident, returnType, argTypes, opts) {\n      return function () {\n        return ccall(ident, returnType, argTypes, arguments, opts);\n      };\n    }\n    /** @type {function(number, number, string, boolean=)} */\n\n\n    function setValue(ptr, value, type, noSafe) {\n      type = type || 'i8';\n      if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n\n      switch (type) {\n        case 'i1':\n          HEAP8[ptr >> 0] = value;\n          break;\n\n        case 'i8':\n          HEAP8[ptr >> 0] = value;\n          break;\n\n        case 'i16':\n          HEAP16[ptr >> 1] = value;\n          break;\n\n        case 'i32':\n          HEAP32[ptr >> 2] = value;\n          break;\n\n        case 'i64':\n          tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? (Math_min(+Math_floor(tempDouble / 4294967296.0), 4294967295.0) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\n          break;\n\n        case 'float':\n          HEAPF32[ptr >> 2] = value;\n          break;\n\n        case 'double':\n          HEAPF64[ptr >> 3] = value;\n          break;\n\n        default:\n          abort('invalid type for setValue: ' + type);\n      }\n    }\n    /** @type {function(number, string, boolean=)} */\n\n\n    function getValue(ptr, type, noSafe) {\n      type = type || 'i8';\n      if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n\n      switch (type) {\n        case 'i1':\n          return HEAP8[ptr >> 0];\n\n        case 'i8':\n          return HEAP8[ptr >> 0];\n\n        case 'i16':\n          return HEAP16[ptr >> 1];\n\n        case 'i32':\n          return HEAP32[ptr >> 2];\n\n        case 'i64':\n          return HEAP32[ptr >> 2];\n\n        case 'float':\n          return HEAPF32[ptr >> 2];\n\n        case 'double':\n          return HEAPF64[ptr >> 3];\n\n        default:\n          abort('invalid type for getValue: ' + type);\n      }\n\n      return null;\n    }\n\n    var ALLOC_NORMAL = 0; // Tries to use _malloc()\n\n    var ALLOC_STACK = 1; // Lives for the duration of the current function call\n\n    var ALLOC_STATIC = 2; // Cannot be freed\n\n    var ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk\n\n    var ALLOC_NONE = 4; // Do not allocate\n    // allocate(): This is for internal use. You can use it yourself as well, but the interface\n    //             is a little tricky (see docs right below). The reason is that it is optimized\n    //             for multiple syntaxes to save space in generated code. So you should\n    //             normally not use allocate(), and instead allocate memory using _malloc(),\n    //             initialize it with setValue(), and so forth.\n    // @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n    //        in *bytes* (note that this is sometimes confusing: the next parameter does not\n    //        affect this!)\n    // @types: Either an array of types, one for each byte (or 0 if no type at that position),\n    //         or a single type which is used for the entire block. This only matters if there\n    //         is initial data - if @slab is a number, then this does not matter at all and is\n    //         ignored.\n    // @allocator: How to allocate memory, see ALLOC_*\n\n    /** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\n\n    function allocate(slab, types, allocator, ptr) {\n      var zeroinit, size;\n\n      if (typeof slab === 'number') {\n        zeroinit = true;\n        size = slab;\n      } else {\n        zeroinit = false;\n        size = slab.length;\n      }\n\n      var singleType = typeof types === 'string' ? types : null;\n      var ret;\n\n      if (allocator == ALLOC_NONE) {\n        ret = ptr;\n      } else {\n        ret = [typeof _malloc === 'function' ? _malloc : staticAlloc, stackAlloc, staticAlloc, dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));\n      }\n\n      if (zeroinit) {\n        var stop;\n        ptr = ret;\n        assert((ret & 3) == 0);\n        stop = ret + (size & ~3);\n\n        for (; ptr < stop; ptr += 4) {\n          HEAP32[ptr >> 2] = 0;\n        }\n\n        stop = ret + size;\n\n        while (ptr < stop) {\n          HEAP8[ptr++ >> 0] = 0;\n        }\n\n        return ret;\n      }\n\n      if (singleType === 'i8') {\n        if (slab.subarray || slab.slice) {\n          HEAPU8.set(\n          /** @type {!Uint8Array} */\n          slab, ret);\n        } else {\n          HEAPU8.set(new Uint8Array(slab), ret);\n        }\n\n        return ret;\n      }\n\n      var i = 0,\n          type,\n          typeSize,\n          previousType;\n\n      while (i < size) {\n        var curr = slab[i];\n        type = singleType || types[i];\n\n        if (type === 0) {\n          i++;\n          continue;\n        }\n\n        assert(type, 'Must know what type to store in allocate!');\n        if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\n\n        setValue(ret + i, curr, type); // no need to look up size unless type changes, so cache it\n\n        if (previousType !== type) {\n          typeSize = getNativeTypeSize(type);\n          previousType = type;\n        }\n\n        i += typeSize;\n      }\n\n      return ret;\n    } // Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\n\n\n    function getMemory(size) {\n      if (!staticSealed) return staticAlloc(size);\n      if (!runtimeInitialized) return dynamicAlloc(size);\n      return _malloc(size);\n    }\n    /** @type {function(number, number=)} */\n\n\n    function Pointer_stringify(ptr, length) {\n      if (length === 0 || !ptr) return ''; // Find the length, and check for UTF while doing so\n\n      var hasUtf = 0;\n      var t;\n      var i = 0;\n\n      while (1) {\n        assert(ptr + i < TOTAL_MEMORY);\n        t = HEAPU8[ptr + i >> 0];\n        hasUtf |= t;\n        if (t == 0 && !length) break;\n        i++;\n        if (length && i == length) break;\n      }\n\n      if (!length) length = i;\n      var ret = '';\n\n      if (hasUtf < 128) {\n        var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack\n\n        var curr;\n\n        while (length > 0) {\n          curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));\n          ret = ret ? ret + curr : curr;\n          ptr += MAX_CHUNK;\n          length -= MAX_CHUNK;\n        }\n\n        return ret;\n      }\n\n      return UTF8ToString(ptr);\n    } // Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n    // a copy of that string as a Javascript String object.\n\n\n    function AsciiToString(ptr) {\n      var str = '';\n\n      while (1) {\n        var ch = HEAP8[ptr++ >> 0];\n        if (!ch) return str;\n        str += String.fromCharCode(ch);\n      }\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\n\n    function stringToAscii(str, outPtr) {\n      return writeAsciiToMemory(str, outPtr, false);\n    } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n    // a copy of that string as a Javascript String object.\n\n\n    var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\n\n    function UTF8ArrayToString(u8Array, idx) {\n      var endPtr = idx; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n      // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n\n      while (u8Array[endPtr]) {\n        ++endPtr;\n      }\n\n      if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n        return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n      } else {\n        var u0, u1, u2, u3, u4, u5;\n        var str = '';\n\n        while (1) {\n          // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n          u0 = u8Array[idx++];\n          if (!u0) return str;\n\n          if (!(u0 & 0x80)) {\n            str += String.fromCharCode(u0);\n            continue;\n          }\n\n          u1 = u8Array[idx++] & 63;\n\n          if ((u0 & 0xE0) == 0xC0) {\n            str += String.fromCharCode((u0 & 31) << 6 | u1);\n            continue;\n          }\n\n          u2 = u8Array[idx++] & 63;\n\n          if ((u0 & 0xF0) == 0xE0) {\n            u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n          } else {\n            u3 = u8Array[idx++] & 63;\n\n            if ((u0 & 0xF8) == 0xF0) {\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u3;\n            } else {\n              u4 = u8Array[idx++] & 63;\n\n              if ((u0 & 0xFC) == 0xF8) {\n                u0 = (u0 & 3) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4;\n              } else {\n                u5 = u8Array[idx++] & 63;\n                u0 = (u0 & 1) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5;\n              }\n            }\n          }\n\n          if (u0 < 0x10000) {\n            str += String.fromCharCode(u0);\n          } else {\n            var ch = u0 - 0x10000;\n            str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n          }\n        }\n      }\n    } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns\n    // a copy of that string as a Javascript String object.\n\n\n    function UTF8ToString(ptr) {\n      return UTF8ArrayToString(HEAPU8, ptr);\n    } // Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n    // encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Parameters:\n    //   str: the Javascript string to copy.\n    //   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n    //   outIdx: The starting offset in the array to begin the copying.\n    //   maxBytesToWrite: The maximum number of bytes this function can write to the array.\n    //                    This count should include the null terminator,\n    //                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n    //                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n      if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n        return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n        var u = str.charCodeAt(i); // possibly a lead surrogate\n\n        if (u >= 0xD800 && u <= 0xDFFF) {\n          var u1 = str.charCodeAt(++i);\n          u = 0x10000 + ((u & 0x3FF) << 10) | u1 & 0x3FF;\n        }\n\n        if (u <= 0x7F) {\n          if (outIdx >= endIdx) break;\n          outU8Array[outIdx++] = u;\n        } else if (u <= 0x7FF) {\n          if (outIdx + 1 >= endIdx) break;\n          outU8Array[outIdx++] = 0xC0 | u >> 6;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        } else if (u <= 0xFFFF) {\n          if (outIdx + 2 >= endIdx) break;\n          outU8Array[outIdx++] = 0xE0 | u >> 12;\n          outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        } else if (u <= 0x1FFFFF) {\n          if (outIdx + 3 >= endIdx) break;\n          outU8Array[outIdx++] = 0xF0 | u >> 18;\n          outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n          outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        } else if (u <= 0x3FFFFFF) {\n          if (outIdx + 4 >= endIdx) break;\n          outU8Array[outIdx++] = 0xF8 | u >> 24;\n          outU8Array[outIdx++] = 0x80 | u >> 18 & 63;\n          outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n          outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        } else {\n          if (outIdx + 5 >= endIdx) break;\n          outU8Array[outIdx++] = 0xFC | u >> 30;\n          outU8Array[outIdx++] = 0x80 | u >> 24 & 63;\n          outU8Array[outIdx++] = 0x80 | u >> 18 & 63;\n          outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n          outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        }\n      } // Null-terminate the pointer to the buffer.\n\n\n      outU8Array[outIdx] = 0;\n      return outIdx - startIdx;\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF8(str, outPtr, maxBytesToWrite) {\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    } // Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\n\n\n    function lengthBytesUTF8(str) {\n      var len = 0;\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var u = str.charCodeAt(i); // possibly a lead surrogate\n\n        if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | str.charCodeAt(++i) & 0x3FF;\n\n        if (u <= 0x7F) {\n          ++len;\n        } else if (u <= 0x7FF) {\n          len += 2;\n        } else if (u <= 0xFFFF) {\n          len += 3;\n        } else if (u <= 0x1FFFFF) {\n          len += 4;\n        } else if (u <= 0x3FFFFFF) {\n          len += 5;\n        } else {\n          len += 6;\n        }\n      }\n\n      return len;\n    } // Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n    // a copy of that string as a Javascript String object.\n\n\n    var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\n\n    function UTF16ToString(ptr) {\n      assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\n      var endPtr = ptr; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n      // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n\n      var idx = endPtr >> 1;\n\n      while (HEAP16[idx]) {\n        ++idx;\n      }\n\n      endPtr = idx << 1;\n\n      if (endPtr - ptr > 32 && UTF16Decoder) {\n        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n      } else {\n        var i = 0;\n        var str = '';\n\n        while (1) {\n          var codeUnit = HEAP16[ptr + i * 2 >> 1];\n          if (codeUnit == 0) return str;\n          ++i; // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n\n          str += String.fromCharCode(codeUnit);\n        }\n      }\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Parameters:\n    //   str: the Javascript string to copy.\n    //   outPtr: Byte address in Emscripten HEAP where to write the string to.\n    //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n    //                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n    //                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF16(str, outPtr, maxBytesToWrite) {\n      assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 0x7FFFFFFF;\n      }\n\n      if (maxBytesToWrite < 2) return 0;\n      maxBytesToWrite -= 2; // Null terminator.\n\n      var startPtr = outPtr;\n      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n\n        HEAP16[outPtr >> 1] = codeUnit;\n        outPtr += 2;\n      } // Null-terminate the pointer to the HEAP.\n\n\n      HEAP16[outPtr >> 1] = 0;\n      return outPtr - startPtr;\n    } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n\n    function lengthBytesUTF16(str) {\n      return str.length * 2;\n    }\n\n    function UTF32ToString(ptr) {\n      assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\n      var i = 0;\n      var str = '';\n\n      while (1) {\n        var utf32 = HEAP32[ptr + i * 4 >> 2];\n        if (utf32 == 0) return str;\n        ++i; // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n\n        if (utf32 >= 0x10000) {\n          var ch = utf32 - 0x10000;\n          str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n        } else {\n          str += String.fromCharCode(utf32);\n        }\n      }\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Parameters:\n    //   str: the Javascript string to copy.\n    //   outPtr: Byte address in Emscripten HEAP where to write the string to.\n    //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n    //                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n    //                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF32(str, outPtr, maxBytesToWrite) {\n      assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 0x7FFFFFFF;\n      }\n\n      if (maxBytesToWrite < 4) return 0;\n      var startPtr = outPtr;\n      var endPtr = startPtr + maxBytesToWrite - 4;\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n\n        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n          var trailSurrogate = str.charCodeAt(++i);\n          codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | trailSurrogate & 0x3FF;\n        }\n\n        HEAP32[outPtr >> 2] = codeUnit;\n        outPtr += 4;\n        if (outPtr + 4 > endPtr) break;\n      } // Null-terminate the pointer to the HEAP.\n\n\n      HEAP32[outPtr >> 2] = 0;\n      return outPtr - startPtr;\n    } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n\n    function lengthBytesUTF32(str) {\n      var len = 0;\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n\n        len += 4;\n      }\n\n      return len;\n    } // Allocate heap space for a JS string, and write it there.\n    // It is the responsibility of the caller to free() that memory.\n\n\n    function allocateUTF8(str) {\n      var size = lengthBytesUTF8(str) + 1;\n\n      var ret = _malloc(size);\n\n      if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n      return ret;\n    } // Allocate stack space for a JS string, and write it there.\n\n\n    function allocateUTF8OnStack(str) {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = stackAlloc(size);\n      stringToUTF8Array(str, HEAP8, ret, size);\n      return ret;\n    }\n\n    function demangle(func) {\n      var __cxa_demangle_func = Module['___cxa_demangle'] || Module['__cxa_demangle'];\n\n      assert(__cxa_demangle_func);\n\n      try {\n        var s = func.substr(1);\n        var len = lengthBytesUTF8(s) + 1;\n\n        var buf = _malloc(len);\n\n        stringToUTF8(s, buf, len);\n\n        var status = _malloc(4);\n\n        var ret = __cxa_demangle_func(buf, 0, 0, status);\n\n        if (HEAP32[status >> 2] === 0 && ret) {\n          return Pointer_stringify(ret);\n        } // otherwise, libcxxabi failed\n\n      } catch (e) {// ignore problems here\n      } finally {\n        if (buf) _free(buf);\n        if (status) _free(status);\n        if (ret) _free(ret);\n      } // failure when using libcxxabi, don't demangle\n\n\n      return func;\n    }\n\n    function demangleAll(text) {\n      var regex = /__Z[\\w\\d_]+/g;\n      return text.replace(regex, function (x) {\n        var y = demangle(x);\n        return x === y ? x : x + ' [' + y + ']';\n      });\n    }\n\n    function jsStackTrace() {\n      var err = new Error();\n\n      if (!err.stack) {\n        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n        // so try that as a special-case.\n        try {\n          throw new Error(0);\n        } catch (e) {\n          err = e;\n        }\n\n        if (!err.stack) {\n          return '(no stack trace available)';\n        }\n      }\n\n      return err.stack.toString();\n    }\n\n    function stackTrace() {\n      var js = jsStackTrace();\n      if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n      return demangleAll(js);\n    } // Memory management\n\n\n    var PAGE_SIZE = 16384;\n    var WASM_PAGE_SIZE = 65536;\n    var ASMJS_PAGE_SIZE = 16777216;\n    var MIN_TOTAL_MEMORY = 16777216;\n\n    function alignUp(x, multiple) {\n      if (x % multiple > 0) {\n        x += multiple - x % multiple;\n      }\n\n      return x;\n    }\n\n    var HEAP,\n    /** @type {ArrayBuffer} */\n    buffer,\n    /** @type {Int8Array} */\n    HEAP8,\n    /** @type {Uint8Array} */\n    HEAPU8,\n    /** @type {Int16Array} */\n    HEAP16,\n    /** @type {Uint16Array} */\n    HEAPU16,\n    /** @type {Int32Array} */\n    HEAP32,\n    /** @type {Uint32Array} */\n    HEAPU32,\n    /** @type {Float32Array} */\n    HEAPF32,\n    /** @type {Float64Array} */\n    HEAPF64;\n\n    function updateGlobalBuffer(buf) {\n      Module['buffer'] = buffer = buf;\n    }\n\n    function updateGlobalBufferViews() {\n      Module['HEAP8'] = HEAP8 = new Int8Array(buffer);\n      Module['HEAP16'] = HEAP16 = new Int16Array(buffer);\n      Module['HEAP32'] = HEAP32 = new Int32Array(buffer);\n      Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);\n      Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);\n      Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);\n      Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);\n      Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);\n    }\n\n    var STATIC_BASE, STATICTOP, staticSealed; // static area\n\n    var STACK_BASE, STACKTOP, STACK_MAX; // stack area\n\n    var DYNAMIC_BASE, DYNAMICTOP_PTR; // dynamic area handled by sbrk\n\n    STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;\n    staticSealed = false; // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\n\n    function writeStackCookie() {\n      assert((STACK_MAX & 3) == 0);\n      HEAPU32[(STACK_MAX >> 2) - 1] = 0x02135467;\n      HEAPU32[(STACK_MAX >> 2) - 2] = 0x89BACDFE;\n    }\n\n    function checkStackCookie() {\n      if (HEAPU32[(STACK_MAX >> 2) - 1] != 0x02135467 || HEAPU32[(STACK_MAX >> 2) - 2] != 0x89BACDFE) {\n        abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x' + HEAPU32[(STACK_MAX >> 2) - 2].toString(16) + ' ' + HEAPU32[(STACK_MAX >> 2) - 1].toString(16));\n      } // Also test the global address 0 for integrity. This check is not compatible with SAFE_SPLIT_MEMORY though, since that mode already tests all address 0 accesses on its own.\n\n\n      if (HEAP32[0] !== 0x63736d65\n      /* 'emsc' */\n      ) throw 'Runtime error: The application has corrupted its heap memory area (address zero)!';\n    }\n\n    function abortStackOverflow(allocSize) {\n      abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - _stackSave() + allocSize) + ' bytes available!');\n    }\n\n    function abortOnCannotGrowMemory() {\n      abort('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\n    }\n\n    function enlargeMemory() {\n      abortOnCannotGrowMemory();\n    }\n\n    var TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;\n    var TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;\n    if (TOTAL_MEMORY < TOTAL_STACK) err('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')'); // Initialize the runtime's memory\n    // check for full engine support (use string 'subarray' to avoid closure compiler confusion)\n\n    assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined, 'JS engine does not provide full typed array support'); // Use a provided buffer, if there is one, or else allocate a new one\n\n    if (Module['buffer']) {\n      buffer = Module['buffer'];\n      assert(buffer.byteLength === TOTAL_MEMORY, 'provided buffer should be ' + TOTAL_MEMORY + ' bytes, but it is ' + buffer.byteLength);\n    } else {\n      // Use a WebAssembly memory where available\n      if ((typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly)) === 'object' && typeof WebAssembly.Memory === 'function') {\n        assert(TOTAL_MEMORY % WASM_PAGE_SIZE === 0);\n        Module['wasmMemory'] = new WebAssembly.Memory({\n          'initial': TOTAL_MEMORY / WASM_PAGE_SIZE,\n          'maximum': TOTAL_MEMORY / WASM_PAGE_SIZE\n        });\n        buffer = Module['wasmMemory'].buffer;\n      } else {\n        buffer = new ArrayBuffer(TOTAL_MEMORY);\n      }\n\n      assert(buffer.byteLength === TOTAL_MEMORY);\n      Module['buffer'] = buffer;\n    }\n\n    updateGlobalBufferViews();\n\n    function getTotalMemory() {\n      return TOTAL_MEMORY;\n    } // Endianness check (note: assumes compiler arch was little-endian)\n\n\n    HEAP32[0] = 0x63736d65;\n    /* 'emsc' */\n\n    HEAP16[1] = 0x6373;\n    if (HEAPU8[2] !== 0x73 || HEAPU8[3] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';\n\n    function callRuntimeCallbacks(callbacks) {\n      while (callbacks.length > 0) {\n        var callback = callbacks.shift();\n\n        if (typeof callback == 'function') {\n          callback();\n          continue;\n        }\n\n        var func = callback.func;\n\n        if (typeof func === 'number') {\n          if (callback.arg === undefined) {\n            Module['dynCall_v'](func);\n          } else {\n            Module['dynCall_vi'](func, callback.arg);\n          }\n        } else {\n          func(callback.arg === undefined ? null : callback.arg);\n        }\n      }\n    }\n\n    var __ATPRERUN__ = []; // functions called before the runtime is initialized\n\n    var __ATINIT__ = []; // functions called during startup\n\n    var __ATMAIN__ = []; // functions called when main() is to be run\n\n    var __ATEXIT__ = []; // functions called during shutdown\n\n    var __ATPOSTRUN__ = []; // functions called after the main() is called\n\n    var runtimeInitialized = false;\n    var runtimeExited = false;\n\n    function preRun() {\n      // compatibility - merge in anything from Module['preRun'] at this time\n      if (Module['preRun']) {\n        if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n\n        while (Module['preRun'].length) {\n          addOnPreRun(Module['preRun'].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n\n    function ensureInitRuntime() {\n      checkStackCookie();\n      if (runtimeInitialized) return;\n      runtimeInitialized = true;\n      callRuntimeCallbacks(__ATINIT__);\n    }\n\n    function preMain() {\n      checkStackCookie();\n      callRuntimeCallbacks(__ATMAIN__);\n    }\n\n    function exitRuntime() {\n      checkStackCookie();\n      callRuntimeCallbacks(__ATEXIT__);\n      runtimeExited = true;\n    }\n\n    function postRun() {\n      checkStackCookie(); // compatibility - merge in anything from Module['postRun'] at this time\n\n      if (Module['postRun']) {\n        if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n\n        while (Module['postRun'].length) {\n          addOnPostRun(Module['postRun'].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n\n    function addOnPreMain(cb) {\n      __ATMAIN__.unshift(cb);\n    }\n\n    function addOnExit(cb) {\n      __ATEXIT__.unshift(cb);\n    }\n\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    } // Deprecated: This function should not be called because it is unsafe and does not provide\n    // a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n    // function stringToUTF8Array() instead, which takes in a maximum length that can be used\n    // to be secure from out of bounds writes.\n\n    /** @deprecated */\n\n\n    function writeStringToMemory(string, buffer, dontAddNull) {\n      warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n      var\n      /** @type {number} */\n      lastChar,\n      /** @type {number} */\n      end;\n\n      if (dontAddNull) {\n        // stringToUTF8Array always appends null. If we don't want to do that, remember the\n        // character that existed at the location where the null will be placed, and restore\n        // that after the write (below).\n        end = buffer + lengthBytesUTF8(string);\n        lastChar = HEAP8[end];\n      }\n\n      stringToUTF8(string, buffer, Infinity);\n      if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n    }\n\n    function writeArrayToMemory(array, buffer) {\n      assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)');\n      HEAP8.set(array, buffer);\n    }\n\n    function writeAsciiToMemory(str, buffer, dontAddNull) {\n      for (var i = 0; i < str.length; ++i) {\n        assert(str.charCodeAt(i) === str.charCodeAt(i) & 0xff);\n        HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n      } // Null-terminate the pointer to the HEAP.\n\n\n      if (!dontAddNull) HEAP8[buffer >> 0] = 0;\n    }\n\n    function unSign(value, bits, ignore) {\n      if (value >= 0) {\n        return value;\n      }\n\n      return bits <= 32 ? 2 * Math.abs(1 << bits - 1) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n      : Math.pow(2, bits) + value;\n    }\n\n    function reSign(value, bits, ignore) {\n      if (value <= 0) {\n        return value;\n      }\n\n      var half = bits <= 32 ? Math.abs(1 << bits - 1) // abs is needed if bits == 32\n      : Math.pow(2, bits - 1);\n\n      if (value >= half && (bits <= 32 || value > half)) {\n        // for huge values, we can hit the precision limit and always get true here. so don't do that\n        // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n        // TODO: In i64 mode 1, resign the two parts separately and safely\n        value = -2 * half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n      }\n\n      return value;\n    }\n\n    assert(Math['imul'] && Math['fround'] && Math['clz32'] && Math['trunc'], 'this is a legacy browser, build with LEGACY_VM_SUPPORT');\n    var Math_abs = Math.abs;\n    var Math_cos = Math.cos;\n    var Math_sin = Math.sin;\n    var Math_tan = Math.tan;\n    var Math_acos = Math.acos;\n    var Math_asin = Math.asin;\n    var Math_atan = Math.atan;\n    var Math_atan2 = Math.atan2;\n    var Math_exp = Math.exp;\n    var Math_log = Math.log;\n    var Math_sqrt = Math.sqrt;\n    var Math_ceil = Math.ceil;\n    var Math_floor = Math.floor;\n    var Math_pow = Math.pow;\n    var Math_imul = Math.imul;\n    var Math_fround = Math.fround;\n    var Math_round = Math.round;\n    var Math_min = Math.min;\n    var Math_max = Math.max;\n    var Math_clz32 = Math.clz32;\n    var Math_trunc = Math.trunc; // A counter of dependencies for calling run(). If we need to\n    // do asynchronous work before running, increment this and\n    // decrement it. Incrementing must happen in a place like\n    // PRE_RUN_ADDITIONS (used by emcc to add file preloading).\n    // Note that you can add dependencies in preRun, even though\n    // it happens right before run - run will be postponed until\n    // the dependencies are met.\n\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n\n    var runDependencyTracking = {};\n\n    function getUniqueRunDependency(id) {\n      var orig = id;\n\n      while (1) {\n        if (!runDependencyTracking[id]) return id;\n        id = orig + Math.random();\n      }\n\n      return id;\n    }\n\n    function addRunDependency(id) {\n      runDependencies++;\n\n      if (Module['monitorRunDependencies']) {\n        Module['monitorRunDependencies'](runDependencies);\n      }\n\n      if (id) {\n        assert(!runDependencyTracking[id]);\n        runDependencyTracking[id] = 1;\n\n        if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {\n          // Check for missing dependencies every few seconds\n          runDependencyWatcher = setInterval(function () {\n            if (ABORT) {\n              clearInterval(runDependencyWatcher);\n              runDependencyWatcher = null;\n              return;\n            }\n\n            var shown = false;\n\n            for (var dep in runDependencyTracking) {\n              if (!shown) {\n                shown = true;\n                err('still waiting on run dependencies:');\n              }\n\n              err('dependency: ' + dep);\n            }\n\n            if (shown) {\n              err('(end of list)');\n            }\n          }, 10000);\n        }\n      } else {\n        err('warning: run dependency added without ID');\n      }\n    }\n\n    function removeRunDependency(id) {\n      runDependencies--;\n\n      if (Module['monitorRunDependencies']) {\n        Module['monitorRunDependencies'](runDependencies);\n      }\n\n      if (id) {\n        assert(runDependencyTracking[id]);\n        delete runDependencyTracking[id];\n      } else {\n        err('warning: run dependency removed without ID');\n      }\n\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback(); // can add another dependenciesFulfilled\n        }\n      }\n    }\n\n    Module[\"preloadedImages\"] = {}; // maps url to image data\n\n    Module[\"preloadedAudios\"] = {}; // maps url to audio data\n\n    var memoryInitializer = null;\n    var\n    /* show errors on likely calls to FS when it was not included */\n    FS = {\n      error: function error() {\n        abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');\n      },\n      init: function init() {\n        FS.error();\n      },\n      createDataFile: function createDataFile() {\n        FS.error();\n      },\n      createPreloadedFile: function createPreloadedFile() {\n        FS.error();\n      },\n      createLazyFile: function createLazyFile() {\n        FS.error();\n      },\n      open: function open() {\n        FS.error();\n      },\n      mkdev: function mkdev() {\n        FS.error();\n      },\n      registerDevice: function registerDevice() {\n        FS.error();\n      },\n      analyzePath: function analyzePath() {\n        FS.error();\n      },\n      loadFilesFromDB: function loadFilesFromDB() {\n        FS.error();\n      },\n      ErrnoError: function ErrnoError() {\n        FS.error();\n      }\n    };\n    Module['FS_createDataFile'] = FS.createDataFile;\n    Module['FS_createPreloadedFile'] = FS.createPreloadedFile; // Prefix of data URIs emitted by SINGLE_FILE and related options.\n\n    var dataURIPrefix = 'data:application/octet-stream;base64,'; // Indicates whether filename is a base64 data URI.\n\n    function isDataURI(filename) {\n      return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;\n    }\n\n    function integrateWasmJS() {\n      // wasm.js has several methods for creating the compiled code module here:\n      //  * 'native-wasm' : use native WebAssembly support in the browser\n      //  * 'interpret-s-expr': load s-expression code from a .wast and interpret\n      //  * 'interpret-binary': load binary wasm and interpret\n      //  * 'interpret-asm2wasm': load asm.js code, translate to wasm, and interpret\n      //  * 'asmjs': no wasm, just load the asm.js code and use that (good for testing)\n      // The method is set at compile time (BINARYEN_METHOD)\n      // The method can be a comma-separated list, in which case, we will try the\n      // options one by one. Some of them can fail gracefully, and then we can try\n      // the next.\n      // inputs\n      var method = 'native-wasm';\n      var wasmTextFile = 'add.wast';\n      var wasmBinaryFile = 'add.wasm';\n      var asmjsCodeFile = 'add.temp.asm.js';\n\n      if (!isDataURI(wasmTextFile)) {\n        wasmTextFile = locateFile(wasmTextFile);\n      }\n\n      if (!isDataURI(wasmBinaryFile)) {\n        wasmBinaryFile = locateFile(wasmBinaryFile);\n      }\n\n      if (!isDataURI(asmjsCodeFile)) {\n        asmjsCodeFile = locateFile(asmjsCodeFile);\n      } // utilities\n\n\n      var wasmPageSize = 64 * 1024;\n      var info = {\n        'global': null,\n        'env': null,\n        'asm2wasm': asm2wasmImports,\n        'parent': Module // Module inside wasm-js.cpp refers to wasm-js.cpp; this allows access to the outside program.\n\n      };\n      var exports = null;\n\n      function mergeMemory(newBuffer) {\n        // The wasm instance creates its memory. But static init code might have written to\n        // buffer already, including the mem init file, and we must copy it over in a proper merge.\n        // TODO: avoid this copy, by avoiding such static init writes\n        // TODO: in shorter term, just copy up to the last static init write\n        var oldBuffer = Module['buffer'];\n\n        if (newBuffer.byteLength < oldBuffer.byteLength) {\n          err('the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here');\n        }\n\n        var oldView = new Int8Array(oldBuffer);\n        var newView = new Int8Array(newBuffer);\n        newView.set(oldView);\n        updateGlobalBuffer(newBuffer);\n        updateGlobalBufferViews();\n      }\n\n      function fixImports(imports) {\n        return imports;\n      }\n\n      function getBinary() {\n        try {\n          if (Module['wasmBinary']) {\n            return new Uint8Array(Module['wasmBinary']);\n          }\n\n          if (Module['readBinary']) {\n            return Module['readBinary'](wasmBinaryFile);\n          } else {\n            throw \"both async and sync fetching of the wasm failed\";\n          }\n        } catch (err) {\n          abort(err);\n        }\n      }\n\n      function getBinaryPromise() {\n        // if we don't have the binary yet, and have the Fetch api, use that\n        // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web\n        if (!Module['wasmBinary'] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {\n          return fetch(wasmBinaryFile, {\n            credentials: 'same-origin'\n          }).then(function (response) {\n            if (!response['ok']) {\n              throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n            }\n\n            return response['arrayBuffer']();\n          }).catch(function () {\n            return getBinary();\n          });\n        } // Otherwise, getBinary should be able to get it synchronously\n\n\n        return new Promise(function (resolve, reject) {\n          resolve(getBinary());\n        });\n      } // do-method functions\n\n\n      function doNativeWasm(global, env, providedBuffer) {\n        if ((typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly)) !== 'object') {\n          // when the method is just native-wasm, our error message can be very specific\n          abort('No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.');\n          err('no native wasm support detected');\n          return false;\n        } // prepare memory import\n\n\n        if (!(Module['wasmMemory'] instanceof WebAssembly.Memory)) {\n          err('no native wasm Memory in use');\n          return false;\n        }\n\n        env['memory'] = Module['wasmMemory']; // Load the wasm module and create an instance of using native support in the JS engine.\n\n        info['global'] = {\n          'NaN': NaN,\n          'Infinity': Infinity\n        };\n        info['global.Math'] = Math;\n        info['env'] = env; // handle a generated wasm instance, receiving its exports and\n        // performing other necessary setup\n\n        function receiveInstance(instance, module) {\n          exports = instance.exports;\n          if (exports.memory) mergeMemory(exports.memory);\n          Module['asm'] = exports;\n          Module[\"usingWasm\"] = true;\n          removeRunDependency('wasm-instantiate');\n        }\n\n        addRunDependency('wasm-instantiate'); // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n        // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n        // to any other async startup actions they are performing.\n\n        if (Module['instantiateWasm']) {\n          try {\n            return Module['instantiateWasm'](info, receiveInstance);\n          } catch (e) {\n            err('Module.instantiateWasm callback failed with error: ' + e);\n            return false;\n          }\n        } // Async compilation can be confusing when an error on the page overwrites Module\n        // (for example, if the order of elements is wrong, and the one defining Module is\n        // later), so we save Module and check it later.\n\n\n        var trueModule = Module;\n\n        function receiveInstantiatedSource(output) {\n          // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\n          // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n          assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n          trueModule = null;\n          receiveInstance(output['instance'], output['module']);\n        }\n\n        function instantiateArrayBuffer(receiver) {\n          getBinaryPromise().then(function (binary) {\n            return WebAssembly.instantiate(binary, info);\n          }).then(receiver).catch(function (reason) {\n            err('failed to asynchronously prepare wasm: ' + reason);\n            abort(reason);\n          });\n        } // Prefer streaming instantiation if available.\n\n\n        if (!Module['wasmBinary'] && typeof WebAssembly.instantiateStreaming === 'function' && !isDataURI(wasmBinaryFile) && typeof fetch === 'function') {\n          WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, {\n            credentials: 'same-origin'\n          }), info).then(receiveInstantiatedSource).catch(function (reason) {\n            // We expect the most common failure cause to be a bad MIME type for the binary,\n            // in which case falling back to ArrayBuffer instantiation should work.\n            err('wasm streaming compile failed: ' + reason);\n            err('falling back to ArrayBuffer instantiation');\n            instantiateArrayBuffer(receiveInstantiatedSource);\n          });\n        } else {\n          instantiateArrayBuffer(receiveInstantiatedSource);\n        }\n\n        return {}; // no exports yet; we'll fill them in later\n      } // We may have a preloaded value in Module.asm, save it\n\n\n      Module['asmPreload'] = Module['asm']; // Memory growth integration code\n\n      var asmjsReallocBuffer = Module['reallocBuffer'];\n\n      var wasmReallocBuffer = function wasmReallocBuffer(size) {\n        var PAGE_MULTIPLE = Module[\"usingWasm\"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE; // In wasm, heap size must be a multiple of 64KB. In asm.js, they need to be multiples of 16MB.\n\n        size = alignUp(size, PAGE_MULTIPLE); // round up to wasm page size\n\n        var old = Module['buffer'];\n        var oldSize = old.byteLength;\n\n        if (Module[\"usingWasm\"]) {\n          // native wasm support\n          try {\n            var result = Module['wasmMemory'].grow((size - oldSize) / wasmPageSize); // .grow() takes a delta compared to the previous size\n\n            if (result !== (-1 | 0)) {\n              // success in native wasm memory growth, get the buffer from the memory\n              return Module['buffer'] = Module['wasmMemory'].buffer;\n            } else {\n              return null;\n            }\n          } catch (e) {\n            console.error('Module.reallocBuffer: Attempted to grow from ' + oldSize + ' bytes to ' + size + ' bytes, but got error: ' + e);\n            return null;\n          }\n        }\n      };\n\n      Module['reallocBuffer'] = function (size) {\n        if (finalMethod === 'asmjs') {\n          return asmjsReallocBuffer(size);\n        } else {\n          return wasmReallocBuffer(size);\n        }\n      }; // we may try more than one; this is the final one, that worked and we are using\n\n\n      var finalMethod = ''; // Provide an \"asm.js function\" for the application, called to \"link\" the asm.js module. We instantiate\n      // the wasm module at that time, and it receives imports and provides exports and so forth, the app\n      // doesn't need to care that it is wasm or olyfilled wasm or asm.js.\n\n      Module['asm'] = function (global, env, providedBuffer) {\n        env = fixImports(env); // import table\n\n        if (!env['table']) {\n          var TABLE_SIZE = Module['wasmTableSize'];\n          if (TABLE_SIZE === undefined) TABLE_SIZE = 1024; // works in binaryen interpreter at least\n\n          var MAX_TABLE_SIZE = Module['wasmMaxTableSize'];\n\n          if ((typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly)) === 'object' && typeof WebAssembly.Table === 'function') {\n            if (MAX_TABLE_SIZE !== undefined) {\n              env['table'] = new WebAssembly.Table({\n                'initial': TABLE_SIZE,\n                'maximum': MAX_TABLE_SIZE,\n                'element': 'anyfunc'\n              });\n            } else {\n              env['table'] = new WebAssembly.Table({\n                'initial': TABLE_SIZE,\n                element: 'anyfunc'\n              });\n            }\n          } else {\n            env['table'] = new Array(TABLE_SIZE); // works in binaryen interpreter at least\n          }\n\n          Module['wasmTable'] = env['table'];\n        }\n\n        if (!env['memoryBase']) {\n          env['memoryBase'] = Module['STATIC_BASE']; // tell the memory segments where to place themselves\n        }\n\n        if (!env['tableBase']) {\n          env['tableBase'] = 0; // table starts at 0 by default, in dynamic linking this will change\n        } // try the methods. each should return the exports if it succeeded\n\n\n        var exports;\n        exports = doNativeWasm(global, env, providedBuffer);\n        assert(exports, 'no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: https://github.com/kripken/emscripten/wiki/WebAssembly#binaryen-methods');\n        return exports;\n      };\n\n      var methodHandler = Module['asm']; // note our method handler, as we may modify Module['asm'] later\n    }\n\n    integrateWasmJS(); // === Body ===\n\n    var ASM_CONSTS = [];\n    STATIC_BASE = GLOBAL_BASE;\n    STATICTOP = STATIC_BASE + 8288;\n    /* global initializers */\n\n    __ATINIT__.push();\n\n    var STATIC_BUMP = 8288;\n    Module[\"STATIC_BASE\"] = STATIC_BASE;\n    Module[\"STATIC_BUMP\"] = STATIC_BUMP;\n    /* no memory initializer */\n\n    var tempDoublePtr = STATICTOP;\n    STATICTOP += 16;\n    assert(tempDoublePtr % 8 == 0);\n\n    function copyTempFloat(ptr) {\n      // functions, because inlining this code increases code size too much\n      HEAP8[tempDoublePtr] = HEAP8[ptr];\n      HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];\n      HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];\n      HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];\n    }\n\n    function copyTempDouble(ptr) {\n      HEAP8[tempDoublePtr] = HEAP8[ptr];\n      HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];\n      HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];\n      HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];\n      HEAP8[tempDoublePtr + 4] = HEAP8[ptr + 4];\n      HEAP8[tempDoublePtr + 5] = HEAP8[ptr + 5];\n      HEAP8[tempDoublePtr + 6] = HEAP8[ptr + 6];\n      HEAP8[tempDoublePtr + 7] = HEAP8[ptr + 7];\n    } // {{PRE_LIBRARY}}\n\n\n    function __ZSt18uncaught_exceptionv() {\n      // std::uncaught_exception()\n      return !!__ZSt18uncaught_exceptionv.uncaught_exception;\n    }\n\n    var EXCEPTIONS = {\n      last: 0,\n      caught: [],\n      infos: {},\n      deAdjust: function deAdjust(adjusted) {\n        if (!adjusted || EXCEPTIONS.infos[adjusted]) return adjusted;\n\n        for (var key in EXCEPTIONS.infos) {\n          var ptr = +key; // the iteration key is a string, and if we throw this, it must be an integer as that is what we look for\n\n          var info = EXCEPTIONS.infos[ptr];\n\n          if (info.adjusted === adjusted) {\n            return ptr;\n          }\n        }\n\n        return adjusted;\n      },\n      addRef: function addRef(ptr) {\n        if (!ptr) return;\n        var info = EXCEPTIONS.infos[ptr];\n        info.refcount++;\n      },\n      decRef: function decRef(ptr) {\n        if (!ptr) return;\n        var info = EXCEPTIONS.infos[ptr];\n        assert(info.refcount > 0);\n        info.refcount--; // A rethrown exception can reach refcount 0; it must not be discarded\n        // Its next handler will clear the rethrown flag and addRef it, prior to\n        // final decRef and destruction here\n\n        if (info.refcount === 0 && !info.rethrown) {\n          if (info.destructor) {\n            Module['dynCall_vi'](info.destructor, ptr);\n          }\n\n          delete EXCEPTIONS.infos[ptr];\n\n          ___cxa_free_exception(ptr);\n        }\n      },\n      clearRef: function clearRef(ptr) {\n        if (!ptr) return;\n        var info = EXCEPTIONS.infos[ptr];\n        info.refcount = 0;\n      }\n    };\n\n    function ___cxa_begin_catch(ptr) {\n      var info = EXCEPTIONS.infos[ptr];\n\n      if (info && !info.caught) {\n        info.caught = true;\n        __ZSt18uncaught_exceptionv.uncaught_exception--;\n      }\n\n      if (info) info.rethrown = false;\n      EXCEPTIONS.caught.push(ptr);\n      EXCEPTIONS.addRef(EXCEPTIONS.deAdjust(ptr));\n      return ptr;\n    }\n\n    function ___resumeException(ptr) {\n      if (!EXCEPTIONS.last) {\n        EXCEPTIONS.last = ptr;\n      }\n\n      throw ptr + \" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.\";\n    }\n\n    function ___cxa_find_matching_catch() {\n      var thrown = EXCEPTIONS.last;\n\n      if (!thrown) {\n        // just pass through the null ptr\n        return (setTempRet0(0), 0) | 0;\n      }\n\n      var info = EXCEPTIONS.infos[thrown];\n      var throwntype = info.type;\n\n      if (!throwntype) {\n        // just pass through the thrown ptr\n        return (setTempRet0(0), thrown) | 0;\n      }\n\n      var typeArray = Array.prototype.slice.call(arguments);\n      var pointer = Module['___cxa_is_pointer_type'](throwntype); // can_catch receives a **, add indirection\n\n      if (!___cxa_find_matching_catch.buffer) ___cxa_find_matching_catch.buffer = _malloc(4);\n      HEAP32[___cxa_find_matching_catch.buffer >> 2] = thrown;\n      thrown = ___cxa_find_matching_catch.buffer; // The different catch blocks are denoted by different types.\n      // Due to inheritance, those types may not precisely match the\n      // type of the thrown object. Find one which matches, and\n      // return the type of the catch block which should be called.\n\n      for (var i = 0; i < typeArray.length; i++) {\n        if (typeArray[i] && Module['___cxa_can_catch'](typeArray[i], throwntype, thrown)) {\n          thrown = HEAP32[thrown >> 2]; // undo indirection\n\n          info.adjusted = thrown;\n          return (setTempRet0(typeArray[i]), thrown) | 0;\n        }\n      } // Shouldn't happen unless we have bogus data in typeArray\n      // or encounter a type for which emscripten doesn't have suitable\n      // typeinfo defined. Best-efforts match just in case.\n\n\n      thrown = HEAP32[thrown >> 2]; // undo indirection\n\n      return (setTempRet0(throwntype), thrown) | 0;\n    }\n\n    function ___gxx_personality_v0() {}\n\n    function ___lock() {}\n\n    var SYSCALLS = {\n      varargs: 0,\n      get: function get(varargs) {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n        return ret;\n      },\n      getStr: function getStr() {\n        var ret = Pointer_stringify(SYSCALLS.get());\n        return ret;\n      },\n      get64: function get64() {\n        var low = SYSCALLS.get(),\n            high = SYSCALLS.get();\n        if (low >= 0) assert(high === 0);else assert(high === -1);\n        return low;\n      },\n      getZero: function getZero() {\n        assert(SYSCALLS.get() === 0);\n      }\n    };\n\n    function ___syscall140(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        // llseek\n        var stream = SYSCALLS.getStreamFromFD(),\n            offset_high = SYSCALLS.get(),\n            offset_low = SYSCALLS.get(),\n            result = SYSCALLS.get(),\n            whence = SYSCALLS.get(); // NOTE: offset_high is unused - Emscripten's off_t is 32-bit\n\n        var offset = offset_low;\n        FS.llseek(stream, offset, whence);\n        HEAP32[result >> 2] = stream.position;\n        if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\n\n        return 0;\n      } catch (e) {\n        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function flush_NO_FILESYSTEM() {\n      // flush anything remaining in the buffers during shutdown\n      var fflush = Module[\"_fflush\"];\n      if (fflush) fflush(0);\n      var printChar = ___syscall146.printChar;\n      if (!printChar) return;\n      var buffers = ___syscall146.buffers;\n      if (buffers[1].length) printChar(1, 10);\n      if (buffers[2].length) printChar(2, 10);\n    }\n\n    function ___syscall146(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        // writev\n        // hack to support printf in NO_FILESYSTEM\n        var stream = SYSCALLS.get(),\n            iov = SYSCALLS.get(),\n            iovcnt = SYSCALLS.get();\n        var ret = 0;\n\n        if (!___syscall146.buffers) {\n          ___syscall146.buffers = [null, [], []]; // 1 => stdout, 2 => stderr\n\n          ___syscall146.printChar = function (stream, curr) {\n            var buffer = ___syscall146.buffers[stream];\n            assert(buffer);\n\n            if (curr === 0 || curr === 10) {\n              (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n              buffer.length = 0;\n            } else {\n              buffer.push(curr);\n            }\n          };\n        }\n\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[iov + i * 8 >> 2];\n          var len = HEAP32[iov + (i * 8 + 4) >> 2];\n\n          for (var j = 0; j < len; j++) {\n            ___syscall146.printChar(stream, HEAPU8[ptr + j]);\n          }\n\n          ret += len;\n        }\n\n        return ret;\n      } catch (e) {\n        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___syscall54(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        // ioctl\n        return 0;\n      } catch (e) {\n        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___syscall6(which, varargs) {\n      SYSCALLS.varargs = varargs;\n\n      try {\n        // close\n        var stream = SYSCALLS.getStreamFromFD();\n        FS.close(stream);\n        return 0;\n      } catch (e) {\n        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n        return -e.errno;\n      }\n    }\n\n    function ___unlock() {}\n\n    function _abort() {\n      Module['abort']();\n    }\n\n    function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.set(HEAPU8.subarray(src, src + num), dest);\n      return dest;\n    }\n\n    var PTHREAD_SPECIFIC = {};\n\n    function _pthread_getspecific(key) {\n      return PTHREAD_SPECIFIC[key] || 0;\n    }\n\n    var PTHREAD_SPECIFIC_NEXT_KEY = 1;\n    var ERRNO_CODES = {\n      EPERM: 1,\n      ENOENT: 2,\n      ESRCH: 3,\n      EINTR: 4,\n      EIO: 5,\n      ENXIO: 6,\n      E2BIG: 7,\n      ENOEXEC: 8,\n      EBADF: 9,\n      ECHILD: 10,\n      EAGAIN: 11,\n      EWOULDBLOCK: 11,\n      ENOMEM: 12,\n      EACCES: 13,\n      EFAULT: 14,\n      ENOTBLK: 15,\n      EBUSY: 16,\n      EEXIST: 17,\n      EXDEV: 18,\n      ENODEV: 19,\n      ENOTDIR: 20,\n      EISDIR: 21,\n      EINVAL: 22,\n      ENFILE: 23,\n      EMFILE: 24,\n      ENOTTY: 25,\n      ETXTBSY: 26,\n      EFBIG: 27,\n      ENOSPC: 28,\n      ESPIPE: 29,\n      EROFS: 30,\n      EMLINK: 31,\n      EPIPE: 32,\n      EDOM: 33,\n      ERANGE: 34,\n      ENOMSG: 42,\n      EIDRM: 43,\n      ECHRNG: 44,\n      EL2NSYNC: 45,\n      EL3HLT: 46,\n      EL3RST: 47,\n      ELNRNG: 48,\n      EUNATCH: 49,\n      ENOCSI: 50,\n      EL2HLT: 51,\n      EDEADLK: 35,\n      ENOLCK: 37,\n      EBADE: 52,\n      EBADR: 53,\n      EXFULL: 54,\n      ENOANO: 55,\n      EBADRQC: 56,\n      EBADSLT: 57,\n      EDEADLOCK: 35,\n      EBFONT: 59,\n      ENOSTR: 60,\n      ENODATA: 61,\n      ETIME: 62,\n      ENOSR: 63,\n      ENONET: 64,\n      ENOPKG: 65,\n      EREMOTE: 66,\n      ENOLINK: 67,\n      EADV: 68,\n      ESRMNT: 69,\n      ECOMM: 70,\n      EPROTO: 71,\n      EMULTIHOP: 72,\n      EDOTDOT: 73,\n      EBADMSG: 74,\n      ENOTUNIQ: 76,\n      EBADFD: 77,\n      EREMCHG: 78,\n      ELIBACC: 79,\n      ELIBBAD: 80,\n      ELIBSCN: 81,\n      ELIBMAX: 82,\n      ELIBEXEC: 83,\n      ENOSYS: 38,\n      ENOTEMPTY: 39,\n      ENAMETOOLONG: 36,\n      ELOOP: 40,\n      EOPNOTSUPP: 95,\n      EPFNOSUPPORT: 96,\n      ECONNRESET: 104,\n      ENOBUFS: 105,\n      EAFNOSUPPORT: 97,\n      EPROTOTYPE: 91,\n      ENOTSOCK: 88,\n      ENOPROTOOPT: 92,\n      ESHUTDOWN: 108,\n      ECONNREFUSED: 111,\n      EADDRINUSE: 98,\n      ECONNABORTED: 103,\n      ENETUNREACH: 101,\n      ENETDOWN: 100,\n      ETIMEDOUT: 110,\n      EHOSTDOWN: 112,\n      EHOSTUNREACH: 113,\n      EINPROGRESS: 115,\n      EALREADY: 114,\n      EDESTADDRREQ: 89,\n      EMSGSIZE: 90,\n      EPROTONOSUPPORT: 93,\n      ESOCKTNOSUPPORT: 94,\n      EADDRNOTAVAIL: 99,\n      ENETRESET: 102,\n      EISCONN: 106,\n      ENOTCONN: 107,\n      ETOOMANYREFS: 109,\n      EUSERS: 87,\n      EDQUOT: 122,\n      ESTALE: 116,\n      ENOTSUP: 95,\n      ENOMEDIUM: 123,\n      EILSEQ: 84,\n      EOVERFLOW: 75,\n      ECANCELED: 125,\n      ENOTRECOVERABLE: 131,\n      EOWNERDEAD: 130,\n      ESTRPIPE: 86\n    };\n\n    function _pthread_key_create(key, destructor) {\n      if (key == 0) {\n        return ERRNO_CODES.EINVAL;\n      }\n\n      HEAP32[key >> 2] = PTHREAD_SPECIFIC_NEXT_KEY; // values start at 0\n\n      PTHREAD_SPECIFIC[PTHREAD_SPECIFIC_NEXT_KEY] = 0;\n      PTHREAD_SPECIFIC_NEXT_KEY++;\n      return 0;\n    }\n\n    function _pthread_once(ptr, func) {\n      if (!_pthread_once.seen) _pthread_once.seen = {};\n      if (ptr in _pthread_once.seen) return;\n      Module['dynCall_v'](func);\n      _pthread_once.seen[ptr] = 1;\n    }\n\n    function _pthread_setspecific(key, value) {\n      if (!(key in PTHREAD_SPECIFIC)) {\n        return ERRNO_CODES.EINVAL;\n      }\n\n      PTHREAD_SPECIFIC[key] = value;\n      return 0;\n    }\n\n    function ___setErrNo(value) {\n      if (Module['___errno_location']) HEAP32[Module['___errno_location']() >> 2] = value;else err('failed to set errno from JS');\n      return value;\n    }\n\n    DYNAMICTOP_PTR = staticAlloc(4);\n    STACK_BASE = STACKTOP = alignMemory(STATICTOP);\n    STACK_MAX = STACK_BASE + TOTAL_STACK;\n    DYNAMIC_BASE = alignMemory(STACK_MAX);\n    HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\n    staticSealed = true; // seal the static portion of memory\n\n    assert(DYNAMIC_BASE < TOTAL_MEMORY, \"TOTAL_MEMORY not big enough for stack\");\n    var ASSERTIONS = true;\n    /** @type {function(string, boolean=, number=)} */\n\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      if (dontAddNull) u8array.length = numBytesWritten;\n      return u8array;\n    }\n\n    function intArrayToString(array) {\n      var ret = [];\n\n      for (var i = 0; i < array.length; i++) {\n        var chr = array[i];\n\n        if (chr > 0xFF) {\n          if (ASSERTIONS) {\n            assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n          }\n\n          chr &= 0xFF;\n        }\n\n        ret.push(String.fromCharCode(chr));\n      }\n\n      return ret.join('');\n    }\n\n    function nullFunc_ii(x) {\n      err(\"Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_iiii(x) {\n      err(\"Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_v(x) {\n      err(\"Invalid function pointer called with signature 'v'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_vi(x) {\n      err(\"Invalid function pointer called with signature 'vi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_viiii(x) {\n      err(\"Invalid function pointer called with signature 'viiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_viiiii(x) {\n      err(\"Invalid function pointer called with signature 'viiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    function nullFunc_viiiiii(x) {\n      err(\"Invalid function pointer called with signature 'viiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n      err(\"Build with ASSERTIONS=2 for more info.\");\n      abort(x);\n    }\n\n    Module['wasmTableSize'] = 178;\n    Module['wasmMaxTableSize'] = 178;\n\n    function invoke_ii(index, a1) {\n      var sp = _stackSave();\n\n      try {\n        return Module[\"dynCall_ii\"](index, a1);\n      } catch (e) {\n        _stackRestore(sp);\n\n        if (typeof e !== 'number' && e !== 'longjmp') throw e;\n        Module[\"setThrew\"](1, 0);\n      }\n    }\n\n    function invoke_iiii(index, a1, a2, a3) {\n      var sp = _stackSave();\n\n      try {\n        return Module[\"dynCall_iiii\"](index, a1, a2, a3);\n      } catch (e) {\n        _stackRestore(sp);\n\n        if (typeof e !== 'number' && e !== 'longjmp') throw e;\n        Module[\"setThrew\"](1, 0);\n      }\n    }\n\n    function invoke_v(index) {\n      var sp = _stackSave();\n\n      try {\n        Module[\"dynCall_v\"](index);\n      } catch (e) {\n        _stackRestore(sp);\n\n        if (typeof e !== 'number' && e !== 'longjmp') throw e;\n        Module[\"setThrew\"](1, 0);\n      }\n    }\n\n    function invoke_vi(index, a1) {\n      var sp = _stackSave();\n\n      try {\n        Module[\"dynCall_vi\"](index, a1);\n      } catch (e) {\n        _stackRestore(sp);\n\n        if (typeof e !== 'number' && e !== 'longjmp') throw e;\n        Module[\"setThrew\"](1, 0);\n      }\n    }\n\n    function invoke_viiii(index, a1, a2, a3, a4) {\n      var sp = _stackSave();\n\n      try {\n        Module[\"dynCall_viiii\"](index, a1, a2, a3, a4);\n      } catch (e) {\n        _stackRestore(sp);\n\n        if (typeof e !== 'number' && e !== 'longjmp') throw e;\n        Module[\"setThrew\"](1, 0);\n      }\n    }\n\n    function invoke_viiiii(index, a1, a2, a3, a4, a5) {\n      var sp = _stackSave();\n\n      try {\n        Module[\"dynCall_viiiii\"](index, a1, a2, a3, a4, a5);\n      } catch (e) {\n        _stackRestore(sp);\n\n        if (typeof e !== 'number' && e !== 'longjmp') throw e;\n        Module[\"setThrew\"](1, 0);\n      }\n    }\n\n    function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {\n      var sp = _stackSave();\n\n      try {\n        Module[\"dynCall_viiiiii\"](index, a1, a2, a3, a4, a5, a6);\n      } catch (e) {\n        _stackRestore(sp);\n\n        if (typeof e !== 'number' && e !== 'longjmp') throw e;\n        Module[\"setThrew\"](1, 0);\n      }\n    }\n\n    Module.asmGlobalArg = {};\n    Module.asmLibraryArg = {\n      \"abort\": abort,\n      \"assert\": assert,\n      \"enlargeMemory\": enlargeMemory,\n      \"getTotalMemory\": getTotalMemory,\n      \"abortOnCannotGrowMemory\": abortOnCannotGrowMemory,\n      \"abortStackOverflow\": abortStackOverflow,\n      \"nullFunc_ii\": nullFunc_ii,\n      \"nullFunc_iiii\": nullFunc_iiii,\n      \"nullFunc_v\": nullFunc_v,\n      \"nullFunc_vi\": nullFunc_vi,\n      \"nullFunc_viiii\": nullFunc_viiii,\n      \"nullFunc_viiiii\": nullFunc_viiiii,\n      \"nullFunc_viiiiii\": nullFunc_viiiiii,\n      \"invoke_ii\": invoke_ii,\n      \"invoke_iiii\": invoke_iiii,\n      \"invoke_v\": invoke_v,\n      \"invoke_vi\": invoke_vi,\n      \"invoke_viiii\": invoke_viiii,\n      \"invoke_viiiii\": invoke_viiiii,\n      \"invoke_viiiiii\": invoke_viiiiii,\n      \"__ZSt18uncaught_exceptionv\": __ZSt18uncaught_exceptionv,\n      \"___cxa_begin_catch\": ___cxa_begin_catch,\n      \"___cxa_find_matching_catch\": ___cxa_find_matching_catch,\n      \"___gxx_personality_v0\": ___gxx_personality_v0,\n      \"___lock\": ___lock,\n      \"___resumeException\": ___resumeException,\n      \"___setErrNo\": ___setErrNo,\n      \"___syscall140\": ___syscall140,\n      \"___syscall146\": ___syscall146,\n      \"___syscall54\": ___syscall54,\n      \"___syscall6\": ___syscall6,\n      \"___unlock\": ___unlock,\n      \"_abort\": _abort,\n      \"_emscripten_memcpy_big\": _emscripten_memcpy_big,\n      \"_pthread_getspecific\": _pthread_getspecific,\n      \"_pthread_key_create\": _pthread_key_create,\n      \"_pthread_once\": _pthread_once,\n      \"_pthread_setspecific\": _pthread_setspecific,\n      \"flush_NO_FILESYSTEM\": flush_NO_FILESYSTEM,\n      \"DYNAMICTOP_PTR\": DYNAMICTOP_PTR,\n      \"tempDoublePtr\": tempDoublePtr,\n      \"ABORT\": ABORT,\n      \"STACKTOP\": STACKTOP,\n      \"STACK_MAX\": STACK_MAX\n    }; // EMSCRIPTEN_START_ASM\n\n    var asm = Module[\"asm\"] // EMSCRIPTEN_END_ASM\n    (Module.asmGlobalArg, Module.asmLibraryArg, buffer);\n    var real____cxa_demangle = asm[\"___cxa_demangle\"];\n\n    asm[\"___cxa_demangle\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real____cxa_demangle.apply(null, arguments);\n    };\n\n    var real____errno_location = asm[\"___errno_location\"];\n\n    asm[\"___errno_location\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real____errno_location.apply(null, arguments);\n    };\n\n    var real__add = asm[\"_add\"];\n\n    asm[\"_add\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__add.apply(null, arguments);\n    };\n\n    var real__fflush = asm[\"_fflush\"];\n\n    asm[\"_fflush\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__fflush.apply(null, arguments);\n    };\n\n    var real__free = asm[\"_free\"];\n\n    asm[\"_free\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__free.apply(null, arguments);\n    };\n\n    var real__llvm_bswap_i32 = asm[\"_llvm_bswap_i32\"];\n\n    asm[\"_llvm_bswap_i32\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__llvm_bswap_i32.apply(null, arguments);\n    };\n\n    var real__malloc = asm[\"_malloc\"];\n\n    asm[\"_malloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__malloc.apply(null, arguments);\n    };\n\n    var real__memmove = asm[\"_memmove\"];\n\n    asm[\"_memmove\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__memmove.apply(null, arguments);\n    };\n\n    var real__sbrk = asm[\"_sbrk\"];\n\n    asm[\"_sbrk\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real__sbrk.apply(null, arguments);\n    };\n\n    var real_establishStackSpace = asm[\"establishStackSpace\"];\n\n    asm[\"establishStackSpace\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_establishStackSpace.apply(null, arguments);\n    };\n\n    var real_getTempRet0 = asm[\"getTempRet0\"];\n\n    asm[\"getTempRet0\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_getTempRet0.apply(null, arguments);\n    };\n\n    var real_setTempRet0 = asm[\"setTempRet0\"];\n\n    asm[\"setTempRet0\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_setTempRet0.apply(null, arguments);\n    };\n\n    var real_setThrew = asm[\"setThrew\"];\n\n    asm[\"setThrew\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_setThrew.apply(null, arguments);\n    };\n\n    var real_stackAlloc = asm[\"stackAlloc\"];\n\n    asm[\"stackAlloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_stackAlloc.apply(null, arguments);\n    };\n\n    var real_stackRestore = asm[\"stackRestore\"];\n\n    asm[\"stackRestore\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_stackRestore.apply(null, arguments);\n    };\n\n    var real_stackSave = asm[\"stackSave\"];\n\n    asm[\"stackSave\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return real_stackSave.apply(null, arguments);\n    };\n\n    Module[\"asm\"] = asm;\n\n    var ___cxa_demangle = Module[\"___cxa_demangle\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"___cxa_demangle\"].apply(null, arguments);\n    };\n\n    var ___errno_location = Module[\"___errno_location\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"___errno_location\"].apply(null, arguments);\n    };\n\n    var _add = Module[\"_add\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_add\"].apply(null, arguments);\n    };\n\n    var _fflush = Module[\"_fflush\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_fflush\"].apply(null, arguments);\n    };\n\n    var _free = Module[\"_free\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_free\"].apply(null, arguments);\n    };\n\n    var _llvm_bswap_i32 = Module[\"_llvm_bswap_i32\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_llvm_bswap_i32\"].apply(null, arguments);\n    };\n\n    var _malloc = Module[\"_malloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_malloc\"].apply(null, arguments);\n    };\n\n    var _memcpy = Module[\"_memcpy\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_memcpy\"].apply(null, arguments);\n    };\n\n    var _memmove = Module[\"_memmove\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_memmove\"].apply(null, arguments);\n    };\n\n    var _memset = Module[\"_memset\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_memset\"].apply(null, arguments);\n    };\n\n    var _sbrk = Module[\"_sbrk\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"_sbrk\"].apply(null, arguments);\n    };\n\n    var establishStackSpace = Module[\"establishStackSpace\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"establishStackSpace\"].apply(null, arguments);\n    };\n\n    var getTempRet0 = Module[\"getTempRet0\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"getTempRet0\"].apply(null, arguments);\n    };\n\n    var runPostSets = Module[\"runPostSets\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"runPostSets\"].apply(null, arguments);\n    };\n\n    var setTempRet0 = Module[\"setTempRet0\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"setTempRet0\"].apply(null, arguments);\n    };\n\n    var setThrew = Module[\"setThrew\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"setThrew\"].apply(null, arguments);\n    };\n\n    var stackAlloc = Module[\"stackAlloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"stackAlloc\"].apply(null, arguments);\n    };\n\n    var _stackRestore = Module[\"stackRestore\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"stackRestore\"].apply(null, arguments);\n    };\n\n    var _stackSave = Module[\"stackSave\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"stackSave\"].apply(null, arguments);\n    };\n\n    var dynCall_ii = Module[\"dynCall_ii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_ii\"].apply(null, arguments);\n    };\n\n    var dynCall_iiii = Module[\"dynCall_iiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_iiii\"].apply(null, arguments);\n    };\n\n    var dynCall_v = Module[\"dynCall_v\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_v\"].apply(null, arguments);\n    };\n\n    var dynCall_vi = Module[\"dynCall_vi\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_vi\"].apply(null, arguments);\n    };\n\n    var dynCall_viiii = Module[\"dynCall_viiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viiii\"].apply(null, arguments);\n    };\n\n    var dynCall_viiiii = Module[\"dynCall_viiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viiiii\"].apply(null, arguments);\n    };\n\n    var dynCall_viiiiii = Module[\"dynCall_viiiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_viiiiii\"].apply(null, arguments);\n    };\n\n    ; // === Auto-generated postamble setup entry stuff ===\n\n    Module['asm'] = asm;\n    if (!Module[\"intArrayFromString\"]) Module[\"intArrayFromString\"] = function () {\n      abort(\"'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"intArrayToString\"]) Module[\"intArrayToString\"] = function () {\n      abort(\"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"ccall\"]) Module[\"ccall\"] = function () {\n      abort(\"'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    Module[\"cwrap\"] = cwrap;\n    if (!Module[\"setValue\"]) Module[\"setValue\"] = function () {\n      abort(\"'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getValue\"]) Module[\"getValue\"] = function () {\n      abort(\"'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"allocate\"]) Module[\"allocate\"] = function () {\n      abort(\"'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getMemory\"]) Module[\"getMemory\"] = function () {\n      abort(\"'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"Pointer_stringify\"]) Module[\"Pointer_stringify\"] = function () {\n      abort(\"'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"AsciiToString\"]) Module[\"AsciiToString\"] = function () {\n      abort(\"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToAscii\"]) Module[\"stringToAscii\"] = function () {\n      abort(\"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"UTF8ArrayToString\"]) Module[\"UTF8ArrayToString\"] = function () {\n      abort(\"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"UTF8ToString\"]) Module[\"UTF8ToString\"] = function () {\n      abort(\"'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToUTF8Array\"]) Module[\"stringToUTF8Array\"] = function () {\n      abort(\"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToUTF8\"]) Module[\"stringToUTF8\"] = function () {\n      abort(\"'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"lengthBytesUTF8\"]) Module[\"lengthBytesUTF8\"] = function () {\n      abort(\"'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"UTF16ToString\"]) Module[\"UTF16ToString\"] = function () {\n      abort(\"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToUTF16\"]) Module[\"stringToUTF16\"] = function () {\n      abort(\"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"lengthBytesUTF16\"]) Module[\"lengthBytesUTF16\"] = function () {\n      abort(\"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"UTF32ToString\"]) Module[\"UTF32ToString\"] = function () {\n      abort(\"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stringToUTF32\"]) Module[\"stringToUTF32\"] = function () {\n      abort(\"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"lengthBytesUTF32\"]) Module[\"lengthBytesUTF32\"] = function () {\n      abort(\"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"allocateUTF8\"]) Module[\"allocateUTF8\"] = function () {\n      abort(\"'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stackTrace\"]) Module[\"stackTrace\"] = function () {\n      abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnPreRun\"]) Module[\"addOnPreRun\"] = function () {\n      abort(\"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnInit\"]) Module[\"addOnInit\"] = function () {\n      abort(\"'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnPreMain\"]) Module[\"addOnPreMain\"] = function () {\n      abort(\"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnExit\"]) Module[\"addOnExit\"] = function () {\n      abort(\"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addOnPostRun\"]) Module[\"addOnPostRun\"] = function () {\n      abort(\"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"writeStringToMemory\"]) Module[\"writeStringToMemory\"] = function () {\n      abort(\"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"writeArrayToMemory\"]) Module[\"writeArrayToMemory\"] = function () {\n      abort(\"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"writeAsciiToMemory\"]) Module[\"writeAsciiToMemory\"] = function () {\n      abort(\"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addRunDependency\"]) Module[\"addRunDependency\"] = function () {\n      abort(\"'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"removeRunDependency\"]) Module[\"removeRunDependency\"] = function () {\n      abort(\"'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"ENV\"]) Module[\"ENV\"] = function () {\n      abort(\"'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"FS\"]) Module[\"FS\"] = function () {\n      abort(\"'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"FS_createFolder\"]) Module[\"FS_createFolder\"] = function () {\n      abort(\"'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createPath\"]) Module[\"FS_createPath\"] = function () {\n      abort(\"'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createDataFile\"]) Module[\"FS_createDataFile\"] = function () {\n      abort(\"'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createPreloadedFile\"]) Module[\"FS_createPreloadedFile\"] = function () {\n      abort(\"'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createLazyFile\"]) Module[\"FS_createLazyFile\"] = function () {\n      abort(\"'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createLink\"]) Module[\"FS_createLink\"] = function () {\n      abort(\"'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_createDevice\"]) Module[\"FS_createDevice\"] = function () {\n      abort(\"'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"FS_unlink\"]) Module[\"FS_unlink\"] = function () {\n      abort(\"'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!Module[\"GL\"]) Module[\"GL\"] = function () {\n      abort(\"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"staticAlloc\"]) Module[\"staticAlloc\"] = function () {\n      abort(\"'staticAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"dynamicAlloc\"]) Module[\"dynamicAlloc\"] = function () {\n      abort(\"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"warnOnce\"]) Module[\"warnOnce\"] = function () {\n      abort(\"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"loadDynamicLibrary\"]) Module[\"loadDynamicLibrary\"] = function () {\n      abort(\"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"loadWebAssemblyModule\"]) Module[\"loadWebAssemblyModule\"] = function () {\n      abort(\"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getLEB\"]) Module[\"getLEB\"] = function () {\n      abort(\"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getFunctionTables\"]) Module[\"getFunctionTables\"] = function () {\n      abort(\"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"alignFunctionTables\"]) Module[\"alignFunctionTables\"] = function () {\n      abort(\"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"registerFunctions\"]) Module[\"registerFunctions\"] = function () {\n      abort(\"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"addFunction\"]) Module[\"addFunction\"] = function () {\n      abort(\"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"removeFunction\"]) Module[\"removeFunction\"] = function () {\n      abort(\"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getFuncWrapper\"]) Module[\"getFuncWrapper\"] = function () {\n      abort(\"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"prettyPrint\"]) Module[\"prettyPrint\"] = function () {\n      abort(\"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"makeBigInt\"]) Module[\"makeBigInt\"] = function () {\n      abort(\"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"dynCall\"]) Module[\"dynCall\"] = function () {\n      abort(\"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"getCompilerSetting\"]) Module[\"getCompilerSetting\"] = function () {\n      abort(\"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stackSave\"]) Module[\"stackSave\"] = function () {\n      abort(\"'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stackRestore\"]) Module[\"stackRestore\"] = function () {\n      abort(\"'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"stackAlloc\"]) Module[\"stackAlloc\"] = function () {\n      abort(\"'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"establishStackSpace\"]) Module[\"establishStackSpace\"] = function () {\n      abort(\"'establishStackSpace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"print\"]) Module[\"print\"] = function () {\n      abort(\"'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"printErr\"]) Module[\"printErr\"] = function () {\n      abort(\"'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!Module[\"ALLOC_NORMAL\"]) Object.defineProperty(Module, \"ALLOC_NORMAL\", {\n      get: function get() {\n        abort(\"'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!Module[\"ALLOC_STACK\"]) Object.defineProperty(Module, \"ALLOC_STACK\", {\n      get: function get() {\n        abort(\"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!Module[\"ALLOC_STATIC\"]) Object.defineProperty(Module, \"ALLOC_STATIC\", {\n      get: function get() {\n        abort(\"'ALLOC_STATIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!Module[\"ALLOC_DYNAMIC\"]) Object.defineProperty(Module, \"ALLOC_DYNAMIC\", {\n      get: function get() {\n        abort(\"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!Module[\"ALLOC_NONE\"]) Object.defineProperty(Module, \"ALLOC_NONE\", {\n      get: function get() {\n        abort(\"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    }); // Modularize mode returns a function, which can be called to\n    // create instances. The instances provide a then() method,\n    // must like a Promise, that receives a callback. The callback\n    // is called when the module is ready to run, with the module\n    // as a parameter. (Like a Promise, it also returns the module\n    // so you can use the output of .then(..)).\n\n    Module['then'] = function (func) {\n      // We may already be ready to run code at this time. if\n      // so, just queue a call to the callback.\n      if (Module['calledRun']) {\n        func(Module);\n      } else {\n        // we are not ready to call then() yet. we must call it\n        // at the same time we would call onRuntimeInitialized.\n        var old = Module['onRuntimeInitialized'];\n\n        Module['onRuntimeInitialized'] = function () {\n          if (old) old();\n          func(Module);\n        };\n      }\n\n      return Module;\n    };\n    /**\n     * @constructor\n     * @extends {Error}\n     * @this {ExitStatus}\n     */\n\n\n    function ExitStatus(status) {\n      this.name = \"ExitStatus\";\n      this.message = \"Program terminated with exit(\" + status + \")\";\n      this.status = status;\n    }\n\n    ;\n    ExitStatus.prototype = new Error();\n    ExitStatus.prototype.constructor = ExitStatus;\n    var initialStackTop;\n    var calledMain = false;\n\n    dependenciesFulfilled = function runCaller() {\n      // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n      if (!Module['calledRun']) run();\n      if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n    };\n    /** @type {function(Array=)} */\n\n\n    function run(args) {\n      args = args || Module['arguments'];\n\n      if (runDependencies > 0) {\n        return;\n      }\n\n      writeStackCookie();\n      preRun();\n      if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\n\n      if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame\n\n      function doRun() {\n        if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening\n\n        Module['calledRun'] = true;\n        if (ABORT) return;\n        ensureInitRuntime();\n        preMain();\n        if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n        assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n        postRun();\n      }\n\n      if (Module['setStatus']) {\n        Module['setStatus']('Running...');\n        setTimeout(function () {\n          setTimeout(function () {\n            Module['setStatus']('');\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n\n      checkStackCookie();\n    }\n\n    Module['run'] = run;\n\n    function checkUnflushedContent() {\n      // Compiler settings do not allow exiting the runtime, so flushing\n      // the streams is not possible. but in ASSERTIONS mode we check\n      // if there was something to flush, and if so tell the user they\n      // should request that the runtime be exitable.\n      // Normally we would not even include flush() at all, but in ASSERTIONS\n      // builds we do so just for this check, and here we see if there is any\n      // content to flush, that is, we check if there would have been\n      // something a non-ASSERTIONS build would have not seen.\n      // How we flush the streams depends on whether we are in NO_FILESYSTEM\n      // mode (which has its own special function for this; otherwise, all\n      // the code is inside libc)\n      var print = out;\n      var printErr = err;\n      var has = false;\n\n      out = err = function err(x) {\n        has = true;\n      };\n\n      try {\n        // it doesn't matter if it fails\n        var flush = flush_NO_FILESYSTEM;\n        if (flush) flush(0);\n      } catch (e) {}\n\n      out = print;\n      err = printErr;\n\n      if (has) {\n        warnOnce('stdio streams had content in them that was not flushed. you should set NO_EXIT_RUNTIME to 0 (see the FAQ), or make sure to emit a newline when you printf etc.');\n      }\n    }\n\n    function exit(status, implicit) {\n      checkUnflushedContent(); // if this is just main exit-ing implicitly, and the status is 0, then we\n      // don't need to do anything here and can just leave. if the status is\n      // non-zero, though, then we need to report it.\n      // (we may have warned about this earlier, if a situation justifies doing so)\n\n      if (implicit && Module['noExitRuntime'] && status === 0) {\n        return;\n      }\n\n      if (Module['noExitRuntime']) {\n        // if exit() was called, we may warn the user if the runtime isn't actually being shut down\n        if (!implicit) {\n          err('exit(' + status + ') called, but NO_EXIT_RUNTIME is set, so halting execution but not exiting the runtime or preventing further async execution (build with NO_EXIT_RUNTIME=0, if you want a true shutdown)');\n        }\n      } else {\n        ABORT = true;\n        EXITSTATUS = status;\n        STACKTOP = initialStackTop;\n        exitRuntime();\n        if (Module['onExit']) Module['onExit'](status);\n      }\n\n      Module['quit'](status, new ExitStatus(status));\n    }\n\n    var abortDecorators = [];\n\n    function abort(what) {\n      if (Module['onAbort']) {\n        Module['onAbort'](what);\n      }\n\n      if (what !== undefined) {\n        out(what);\n        err(what);\n        what = JSON.stringify(what);\n      } else {\n        what = '';\n      }\n\n      ABORT = true;\n      EXITSTATUS = 1;\n      var extra = '';\n      var output = 'abort(' + what + ') at ' + stackTrace() + extra;\n\n      if (abortDecorators) {\n        abortDecorators.forEach(function (decorator) {\n          output = decorator(output, what);\n        });\n      }\n\n      throw output;\n    }\n\n    Module['abort'] = abort; // {{PRE_RUN_ADDITIONS}}\n\n    if (Module['preInit']) {\n      if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n\n      while (Module['preInit'].length > 0) {\n        Module['preInit'].pop()();\n      }\n    }\n\n    Module[\"noExitRuntime\"] = true;\n    run(); // {{POST_RUN_ADDITIONS}}\n    // {{MODULE_ADDITIONS}}\n\n    return Module;\n  };\n}();\n\nif ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') module.exports = Module;else if (typeof define === 'function' && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) define([], function () {\n  return Module;\n});else if ((typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) === 'object') exports[\"Module\"] = Module;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Module);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/process/browser.js */ \"./node_modules/process/browser.js\"), \"/\", __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))\n\n//# sourceURL=webpack:///./wasm/add.js?"
      );

      /** */
    }

    /** *** */
  }
));
